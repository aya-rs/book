<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building eBPF Programs With Aya</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ebpf/index.html"><strong aria-hidden="true">2.</strong> eBPF Program Limitiations</a></li><li class="chapter-item expanded "><a href="start/index.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/development.html"><strong aria-hidden="true">3.1.</strong> Development Environment</a></li><li class="chapter-item expanded "><a href="start/hello-xdp.html"><strong aria-hidden="true">3.2.</strong> Hello XDP!</a></li><li class="chapter-item expanded "><a href="start/logging-packets.html"><strong aria-hidden="true">3.3.</strong> Logging Packets</a></li><li class="chapter-item expanded "><a href="start/dropping-packets.html"><strong aria-hidden="true">3.4.</strong> Dropping Packets</a></li></ol></li><li class="chapter-item expanded "><a href="aya/index.html"><strong aria-hidden="true">4.</strong> Working With Aya</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="aya/context.html"><strong aria-hidden="true">4.1.</strong> Reading Values From A Context</a></li><li class="chapter-item expanded "><a href="aya/aya-gen.html"><strong aria-hidden="true">4.2.</strong> Using aya-gen</a></li><li class="chapter-item expanded "><a href="aya/aya-log.html"><strong aria-hidden="true">4.3.</strong> Using aya-log</a></li></ol></li><li class="chapter-item expanded "><a href="programs/index.html"><strong aria-hidden="true">5.</strong> Program Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programs/probes.html"><strong aria-hidden="true">5.1.</strong> Probes</a></li><li class="chapter-item expanded "><a href="programs/tracepoints.html"><strong aria-hidden="true">5.2.</strong> Tracepoints</a></li><li class="chapter-item expanded "><a href="programs/sockets.html"><strong aria-hidden="true">5.3.</strong> Socket Programs</a></li><li class="chapter-item expanded "><a href="programs/classifiers.html"><strong aria-hidden="true">5.4.</strong> Classifiers</a></li><li class="chapter-item expanded "><a href="programs/cgroups.html"><strong aria-hidden="true">5.5.</strong> Cgroups</a></li><li class="chapter-item expanded "><a href="programs/xdp.html"><strong aria-hidden="true">5.6.</strong> XDP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building eBPF Programs With Aya</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to Building eBPF Programs with Aya: An introductory book about using the Rust
Programming Language and Aya library to build extended Berkley Packet Filter (eBPF)
programs.</p>
<h2 id="who-aya-is-for"><a class="header" href="#who-aya-is-for">Who Aya Is For</a></h2>
<p>Rust is proving to be a popular systems programming language because of its
safety features and excellent C interoperability. The safety features are less
important in the context of eBPF as programs often need to read kernel memory, which
is considered unsafe. However, what Rust combined with Aya does offer is a fast and 
efficient development experience:</p>
<ul>
<li>Cargo for project scaffolding, build, test and debugging</li>
<li>Generation of Rust bindings to Kernel Headers with Compile-Once, Run-Everywhere (CO-RE) support</li>
<li>Easy code sharing between user-space and eBPF programs</li>
<li>Fast compile times</li>
<li>No runtime dependency on LLVM or BCC</li>
</ul>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>The goals of this book are:</p>
<ul>
<li>
<p>Get developers up to speed with eBPF Rust development. i.e. How to set
up a development environment.</p>
</li>
<li>
<p>Share <em>current</em> best practices about using Rust for eBPF</p>
</li>
</ul>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book is For</a></h2>
<p>This book caters towards people with either some eBPF or some Rust background. For those without any prior knowledge we suggest you read the &quot;Assumptions and Prerequisites&quot; section first. You can check out the &quot;Other Resources&quot; section to find resources on topics you might want to read up on.</p>
<h3 id="assumptions-and-prerequisites"><a class="header" href="#assumptions-and-prerequisites">Assumptions and Prerequisites</a></h3>
<ul>
<li>You are comfortable using the Rust Programming Language, and have written,
run, and debugged Rust applications on a desktop environment. You should also
be familiar with the idioms of the <a href="https://doc.rust-lang.org/edition-guide/">2018 edition</a> as this book targets
Rust 2018.</li>
</ul>
<ul>
<li>You are familiar with the core concepts of eBPF</li>
</ul>
<h3 id="other-resources"><a class="header" href="#other-resources">Other Resources</a></h3>
<p>If you are unfamiliar with anything mentioned above or if you want more information about a specific topic mentioned in this book you might find some of these resources helpful.</p>
<table><thead><tr><th>Topic</th><th>Resource</th><th>Description</th></tr></thead><tbody>
<tr><td>Rust</td><td><a href="https://doc.rust-lang.org/book/">Rust Book</a></td><td>If you are not yet comfortable with Rust, we highly suggest reading this book.</td></tr>
<tr><td>eBPF</td><td><a href="https://docs.cilium.io/en/stable/bpf/">Cilium BPF and XDP Reference Guide</a></td><td>If you are not yet comfortable with eBPF, this guide is excellent.</td></tr>
</tbody></table>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h2>
<p>This book generally assumes that youâ€™re reading it front-to-back. Later
chapters build on concepts in earlier chapters, and earlier chapters may
not dig into details on a topic, revisiting the topic in a later chapter.</p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>The source files from which this book is generated can be found on <a href="https://github.com/aya-rs/book">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ebpf-program-constraints"><a class="header" href="#ebpf-program-constraints">eBPF Program Constraints</a></h1>
<p>The eBPF Virtual Machine, where our eBPF programs will be run, is a constrained runtime environment:</p>
<ul>
<li>There is only 512 bytes of stack (or 256 bytes if we are using tail calls).</li>
<li>There is no access to heap space and data must instead be written to maps.</li>
</ul>
<p>Even applications written in C are restricted to a subset of language features:</p>
<ul>
<li>no loops</li>
<li>no global variables</li>
<li>no variadic functions</li>
<li>no floating-point numbers</li>
<li>no passing structures as function arguments</li>
</ul>
<p>While these limitations do not map 1:1 with Rust, we are still constrained:</p>
<ul>
<li>We may not use the standard library. We use <code>core</code> instead.</li>
<li><code>core::fmt</code> may not be used and neither can traits that rely on it, for example <code>Display</code> and <code>Debug</code></li>
<li>As there is no heap, we cannot use <code>alloc</code> or <code>collections</code>.</li>
<li>We must not <code>panic</code> as the eBPF VM does not support stack unwinding, or the <code>abort</code> instruction.</li>
<li>There is no <code>main</code> function</li>
</ul>
<p>Alongside this, a lot of the code that we write is <code>unsafe</code>, as we are reading directly from kernel memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this section we'll walk you through the process of writing, building
and running a simple eBPF program and userspace application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before getting started you will need the Rust stable and nightly tool-chains installed on your system.
This is easily achieved with <a href="https://rustup.rs"><code>rustup</code></a>:</p>
<pre><code class="language-console">rustup install stable
rustup toolchain install nightly --component rust-src
</code></pre>
<p>Once you have the Rust tool-chains installed, you must also install the <code>bpf-linker</code> - for linking our eBPF program - and <code>cargo-generate</code> - for generating the project skeleton.</p>
<pre><code class="language-console">cargo +nightly install bpf-linker
cargo install --git http://github.com/cargo-generate/cargo-generate cargo-generate
</code></pre>
<p>If you don't have and don't want to install LLVM, you can use rust-llvm feature:</p>
<pre><code class="language-console">cargo install --git https://github.com/aya-rs/bpf-linker  --tag v0.9.2 --no-default-features --features rust-llvm -- bpf-linker
</code></pre>
<h2 id="starting-a-new-project"><a class="header" href="#starting-a-new-project">Starting A New Project</a></h2>
<p>To start a new project, you can use <code>cargo-generate</code>:</p>
<pre><code class="language-console">cargo generate https://github.com/aya-rs/aya-template
</code></pre>
<p>This will prompt you for a project name - we'll be using <code>myapp</code> in this example. It will also prompt you for a program type and possibly other options depending on the chosen type (for example, the attach direction for network classifiers).</p>
<p>If you prefer, you can set template options directly from the command line:</p>
<pre><code class="language-console">cargo generate --name xdpfw -d program_type=xdp https://github.com/aya-rs/aya-template
</code></pre>
<p>or</p>
<pre><code class="language-console">cargo generate --name tcfw -d program_type=classifier -d direction=Ingress https://github.com/aya-rs/aya-template
</code></pre>
<p>See https://github.com/aya-rs/aya-template/blob/main/cargo-generate.toml for the full list of available options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-xdp"><a class="header" href="#hello-xdp">Hello XDP!</a></h1>
<h2 id="example-project"><a class="header" href="#example-project">Example Project</a></h2>
<p>While there are myriad trace points to attach to and program types to write we should start somewhere simple.</p>
<p>XDP (eXpress Data Path) programs permit our eBPF program to make decisions about packets that have been received on the interface to which our program is attached. To keep things simple, we'll build a very simplistic firewall to permit or deny traffic.</p>
<h2 id="ebpf-component"><a class="header" href="#ebpf-component">eBPF Component</a></h2>
<h3 id="permit-all"><a class="header" href="#permit-all">Permit All</a></h3>
<p>We must first write the eBPF component of our program.
The logic for this program is located in <code>myapp-ebpf/src/main.rs</code> and currently looks like this:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

#[panic_handler]
fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    unreachable!()
}
</code></pre>
<ul>
<li><code>#![no_std]</code> is required since we cannot use the standard library.</li>
<li><code>#![no_main]</code> is required as we have no main function.</li>
<li>The <code>#[panic_handler]</code> is required to keep the compiler happy, although it is never used since we cannot panic.</li>
</ul>
<p>Let's expand this by adding an XDP program that permits all traffic.</p>
<p>First we'll make some use declarations:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span>use aya_bpf::bindings::xdp_action;
use aya_bpf::cty::c_long;
use aya_bpf::macros::xdp;
use aya_bpf::programs::XdpContext;
<span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unreachable!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[xdp]
</span><span class="boring">pub fn xdp_firewall(ctx: XdpContext) -&gt; u32 {
</span><span class="boring">    match unsafe { try_xdp_firewall(ctx) } {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(_) =&gt; xdp_action::XDP_ABORTED,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">unsafe fn try_xdp_firewall(_ctx: XdpContext) -&gt; Result&lt;u32, c_long&gt; {
</span><span class="boring">    Ok(xdp_action::XDP_PASS)
</span><span class="boring">}
</span></code></pre>
<p>Then our application logic:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::bindings::xdp_action;
</span><span class="boring">use aya_bpf::cty::c_long;
</span><span class="boring">use aya_bpf::macros::xdp;
</span><span class="boring">use aya_bpf::programs::XdpContext;
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unreachable!()
</span><span class="boring">}
</span><span class="boring">
</span>#[xdp]
pub fn xdp_firewall(ctx: XdpContext) -&gt; u32 {
    match unsafe { try_xdp_firewall(ctx) } {
        Ok(ret) =&gt; ret,
        Err(_) =&gt; xdp_action::XDP_ABORTED,
    }
}

unsafe fn try_xdp_firewall(_ctx: XdpContext) -&gt; Result&lt;u32, c_long&gt; {
    Ok(xdp_action::XDP_PASS)
}
</code></pre>
<ul>
<li><code>#[xdp]</code> indicates that this function is an XDP program</li>
<li>The <code>try_xdp_firewall</code> function returns a Result that permits all traffic</li>
<li>The <code>xdp_firewall</code> program calls <code>try_xdp_firewall</code> and handles any errors by returning <code>XDP_ABORTED</code>, which will drop the packet and raise a tracepoint exception.</li>
</ul>
<p>Now we can compile this using <code>cargo xtask build-ebpf</code></p>
<h3 id="verifying-the-program"><a class="header" href="#verifying-the-program">Verifying The Program</a></h3>
<p>Let's take a look at the compiled eBPF program:</p>
<pre><code class="language-console">$ llvm-objdump -S target/bpfel-unknown-none/debug/myapp

target/bpfel-unknown-none/debug/myapp:  file format elf64-bpf


Disassembly of section xdp:

0000000000000000 &lt;xdp_firewall&gt;:
       0:       b7 00 00 00 02 00 00 00 r0 = 2
       1:       95 00 00 00 00 00 00 00 exit
</code></pre>
<p>We can see an <code>xdp_firewall</code> section here.
<code>r0 = 2</code> sets register <code>0</code> to <code>2</code>, which is the value of the <code>XDP_PASS</code> action.
<code>exit</code> ends the program.</p>
<p>Simple!</p>
<h2 id="user-space-component"><a class="header" href="#user-space-component">User-space Component</a></h2>
<p>Now our eBPF program is complete and compiled, we need a user-space program to load it and attach it to a trace point.
Fortunately, we have a program ready in <code>myapp/src/main.rs</code> which is going to do that for us.</p>
<h3 id="starting-out"><a class="header" href="#starting-out">Starting Out</a></h3>
<p>The generated application has the following content:</p>
<pre><code class="language-rust ignore">fn main() {
    if let Err(e) = try_main() {
        eprintln!(&quot;error: {:#}&quot;, e);
    }
}

fn try_main() -&gt; Result&lt;(), anyhow::Error&gt; {
    Ok(())
}
</code></pre>
<p>Let's adapt it to load our program.</p>
<p>We will add a dependency on <code>ctrlc</code> to <code>myapp/Cargo.toml</code>:</p>
<pre><code class="language-toml">ctrlc = &quot;3.2&quot;
</code></pre>
<p>Add the following declarations at the top of the <code>myapp/src/main.rs</code>:</p>
<pre><code class="language-rust ignore">use aya::Bpf;
use aya::programs::{Xdp, XdpFlags};
use std::{
    convert::TryInto,
    env,
    sync::Arc,
    sync::atomic::{AtomicBool, Ordering},
    thread,
    time::Duration
};
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Err(e) = try_main() {
</span><span class="boring">        eprintln!(&quot;error: {:#}&quot;, e);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn try_main() -&gt; Result&lt;(), anyhow::Error&gt; {
</span><span class="boring">    let path = match env::args().nth(1) {
</span><span class="boring">        Some(iface) =&gt; iface,
</span><span class="boring">        None =&gt; panic!(&quot;not path provided&quot;),
</span><span class="boring">    };
</span><span class="boring">    let iface = match env::args().nth(2) {
</span><span class="boring">        Some(iface) =&gt; iface,
</span><span class="boring">        None =&gt; &quot;eth0&quot;.to_string(),
</span><span class="boring">    };
</span><span class="boring">    let mut bpf = Bpf::load_file(&amp;path)?;
</span><span class="boring">    let probe: &amp;mut Xdp = bpf.program_mut(&quot;xdp&quot;)?.try_into()?;
</span><span class="boring">    probe.load()?;
</span><span class="boring">    probe.attach(&amp;iface, XdpFlags::default())?;
</span><span class="boring">
</span><span class="boring">    let running = Arc::new(AtomicBool::new(true));
</span><span class="boring">    let r = running.clone();
</span><span class="boring">
</span><span class="boring">    ctrlc::set_handler(move || {
</span><span class="boring">        r.store(false, Ordering::SeqCst);
</span><span class="boring">    }).expect(&quot;Error setting Ctrl-C handler&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Waiting for Ctrl-C...&quot;);
</span><span class="boring">    while running.load(Ordering::SeqCst) {
</span><span class="boring">        thread::sleep(Duration::from_millis(500))
</span><span class="boring">    }
</span><span class="boring">    println!(&quot;Exiting...&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Then we'll adapt the <code>try_main</code> function to load our program:</p>
<pre><code class="language-rust ignore"><span class="boring">use aya::Bpf;
</span><span class="boring">use aya::programs::{Xdp, XdpFlags};
</span><span class="boring">use std::{
</span><span class="boring">    convert::TryInto,
</span><span class="boring">    env,
</span><span class="boring">    sync::Arc,
</span><span class="boring">    sync::atomic::{AtomicBool, Ordering},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Err(e) = try_main() {
</span><span class="boring">        eprintln!(&quot;error: {:#}&quot;, e);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn try_main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let path = match env::args().nth(1) {
        Some(iface) =&gt; iface,
        None =&gt; panic!(&quot;not path provided&quot;),
    };
    let iface = match env::args().nth(2) {
        Some(iface) =&gt; iface,
        None =&gt; &quot;eth0&quot;.to_string(),
    };
    let mut bpf = Bpf::load_file(&amp;path)?;
    let probe: &amp;mut Xdp = bpf.program_mut(&quot;xdp&quot;)?.try_into()?;
    probe.load()?;
    probe.attach(&amp;iface, XdpFlags::default())?;

    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();

    ctrlc::set_handler(move || {
        r.store(false, Ordering::SeqCst);
    }).expect(&quot;Error setting Ctrl-C handler&quot;);

    println!(&quot;Waiting for Ctrl-C...&quot;);
    while running.load(Ordering::SeqCst) {
        thread::sleep(Duration::from_millis(500))
    }
    println!(&quot;Exiting...&quot;);

    Ok(())
}
</code></pre>
<p>The program takes two positional arguments</p>
<ul>
<li>The path to our eBPF application</li>
<li>The interface we wish to attach it to (defaults to <code>eth0</code>)</li>
</ul>
<p>The line <code>let mut bpf = Bpf::load_file(&amp;path)?;</code>:</p>
<ul>
<li>Opens the file</li>
<li>Reads the ELF contents</li>
<li>Creates any maps</li>
<li>If your system supports BPF Type Format (BTF), it will read the current BTF description and performs any necessary relocations</li>
</ul>
<p>Once our file is loaded, we can extract the XDP probe with <code>let probe: &amp;mut Xdp = bpf.program_mut(&quot;xdp&quot;)?.try_into()?;</code> and then load it in to the kernel with <code>probe.load()</code>.</p>
<p>Finally, we can attach it to an interface with <code>probe.attach(&amp;iface, XdpFlags::default())?;</code></p>
<p>Let's try it out!</p>
<pre><code class="language-console">$ cargo build
$ sudo ./target/debug/myapp --path ./target/bpfel-unknown-none/debug/myapp wlp2s0
Waiting for Ctrl-C...
Exiting...
</code></pre>
<p>That was uneventful. Did it work?</p>
<blockquote>
<p>ðŸ’¡ <strong>HINT: Error Loading Program?</strong></p>
<p>If you get an error loading the program, try changing <code>XdpFlags::default()</code> to <code>XdpFlags::SKB_MODE</code></p>
</blockquote>
<h3 id="the-lifecycle-of-an-ebpf-program"><a class="header" href="#the-lifecycle-of-an-ebpf-program">The Lifecycle of an eBPF Program</a></h3>
<p>The program runs until CTRL+C is pressed and then exits.
On exit, Aya takes care of detaching the program for us.</p>
<p>If you issue the <code>sudo bpftool prog list</code> command when <code>myapp</code> is running you can verify that it is loaded:</p>
<pre><code class="language-console">84: xdp  tag 3b185187f1855c4c  gpl
        loaded_at 2021-08-05T13:35:06+0100  uid 0
        xlated 16B  jited 18B  memlock 4096B
        pids myapp(69184)
</code></pre>
<p>Running the command again once <code>myapp</code> has exited will show that the program is no longer running.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-packets"><a class="header" href="#logging-packets">Logging Packets</a></h1>
<p>In the previous chapter, our XDP application ran for 10 seconds and permitted some traffic.
There was however no output on the console, so you just have to trust that it was working correctly. Let's expand this program to log the traffic that is being permitted</p>
<h2 id="getting-data-to-user-space"><a class="header" href="#getting-data-to-user-space">Getting Data to User-Space</a></h2>
<h3 id="sharing-data"><a class="header" href="#sharing-data">Sharing Data</a></h3>
<p>To get data from kernel-space to user-space we use an eBPF map. There are numerous types of maps to chose from, but in this example we'll be using a PerfEventArray.</p>
<p>While we could go all out and extract data all the way up to L7, we'll constrain our firewall to L3, and to make things easier, IPv4 only.
The data structure that we'll need to send information to user-space will need to hold an IPv4 address and an action for Permit/Deny, we'll encode both as a <code>u32</code>.</p>
<p>Let's go ahead and add that to <code>myapp-common/src/lib.rs</code></p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">
</span>#[repr(C)]
pub struct PacketLog {
    pub ipv4_address: u32,
    pub action: u32,
}
<span class="boring">
</span><span class="boring">#[cfg(feature = &quot;user&quot;)]
</span><span class="boring">unsafe impl aya::Pod for PacketLog {}
</span></code></pre>
<blockquote>
<p>ðŸ’¡ <strong>HINT: Struct Alignment</strong></p>
<p>Structs must be aligned to 8 byte boundaries. You can do this manually, or alternatively you may use <code>#[repr(packed)]</code>. If you do not do this, the eBPF verifier will get upset and emit an <code>invalid indirect read from stack</code> error.</p>
</blockquote>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">
</span><span class="boring">#[repr(C)]
</span><span class="boring">pub struct PacketLog {
</span><span class="boring">    pub ipv4_address: u32,
</span><span class="boring">    pub action: u32,
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(feature = &quot;user&quot;)]
unsafe impl aya::Pod for PacketLog {}
</code></pre>
<p>We implement the <code>aya::Pod</code> trait for our struct since it is Plain Old Data as can be safely converted to a byte-slice and back.</p>
<h3 id="ebpf-map-creation"><a class="header" href="#ebpf-map-creation">eBPF: Map Creation</a></h3>
<p>Let's create a map called <code>EVENTS</code> in <code>myapp-ebpf/src/main.rs</code></p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{
</span><span class="boring">    bindings::xdp_action,
</span><span class="boring">    macros::{map, xdp},
</span><span class="boring">    maps::PerfEventArray,
</span><span class="boring">    programs::XdpContext,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use core::mem;
</span><span class="boring">use memoffset::offset_of;
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span><span class="boring">mod bindings;
</span><span class="boring">use bindings::{ethhdr, iphdr};
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unreachable!()
</span><span class="boring">}
</span><span class="boring">
</span>#[map(name = &quot;EVENTS&quot;)]
static mut EVENTS: PerfEventArray&lt;PacketLog&gt; = PerfEventArray::&lt;PacketLog&gt;::with_max_entries(1024, 0);
<span class="boring">
</span><span class="boring">#[xdp]
</span><span class="boring">pub fn xdp_firewall(ctx: XdpContext) -&gt; u32 {
</span><span class="boring">    match try_xdp_firewall(ctx) {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(_) =&gt; xdp_action::XDP_ABORTED,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[inline(always)]
</span><span class="boring">unsafe fn ptr_at&lt;T&gt;(ctx: &amp;XdpContext, offset: usize) -&gt; Result&lt;*const T, ()&gt; {
</span><span class="boring">    let start = ctx.data();
</span><span class="boring">    let end = ctx.data_end();
</span><span class="boring">    let len = mem::size_of::&lt;T&gt;();
</span><span class="boring">
</span><span class="boring">    if start + offset + len &gt; end {
</span><span class="boring">        return Err(());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok((start + offset) as *const T)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn try_xdp_firewall(ctx: XdpContext) -&gt; Result&lt;u32, ()&gt; {
</span><span class="boring">    let h_proto = u16::from_be(unsafe { *ptr_at(&amp;ctx, offset_of!(ethhdr, h_proto))? });
</span><span class="boring">    if h_proto != ETH_P_IP {
</span><span class="boring">        return Ok(xdp_action::XDP_PASS);
</span><span class="boring">    }
</span><span class="boring">    let source = u32::from_be(unsafe { *ptr_at(&amp;ctx, ETH_HDR_LEN + offset_of!(iphdr, saddr))? });
</span><span class="boring">
</span><span class="boring">    let log_entry = PacketLog {
</span><span class="boring">        ipv4_address: source,
</span><span class="boring">        action: xdp_action::XDP_PASS,
</span><span class="boring">    };
</span><span class="boring">    unsafe {
</span><span class="boring">        EVENTS.output(&amp;ctx, &amp;log_entry, 0);
</span><span class="boring">    }
</span><span class="boring">    Ok(xdp_action::XDP_PASS)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ETH_P_IP: u16 = 0x0800;
</span><span class="boring">const ETH_HDR_LEN: usize = mem::size_of::&lt;ethhdr&gt;();
</span></code></pre>
<p>When the eBPF program is loaded by Aya, the map will be created for us.</p>
<h3 id="userspace-map-creation"><a class="header" href="#userspace-map-creation">Userspace: Map Creation</a></h3>
<p>After our call to <code>probe.attach()</code> we'll add the following code.</p>
<pre><code class="language-rust ignore"><span class="boring">use aya::{
</span><span class="boring">    maps::perf::AsyncPerfEventArray,
</span><span class="boring">    programs::{Xdp, XdpFlags},
</span><span class="boring">    util::online_cpus,
</span><span class="boring">    Bpf,
</span><span class="boring">};
</span><span class="boring">use bytes::BytesMut;
</span><span class="boring">use std::{
</span><span class="boring">    convert::{TryFrom, TryInto},
</span><span class="boring">    env, fs, net,
</span><span class="boring">};
</span><span class="boring">use tokio::{signal, task};
</span><span class="boring">
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
</span><span class="boring">    let path = match env::args().nth(1) {
</span><span class="boring">        Some(iface) =&gt; iface,
</span><span class="boring">        None =&gt; panic!(&quot;not path provided&quot;),
</span><span class="boring">    };
</span><span class="boring">    let iface = match env::args().nth(2) {
</span><span class="boring">        Some(iface) =&gt; iface,
</span><span class="boring">        None =&gt; &quot;eth0&quot;.to_string(),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let data = fs::read(path)?;
</span><span class="boring">    let mut bpf = Bpf::load(&amp;data)?;
</span><span class="boring">
</span><span class="boring">    let probe: &amp;mut Xdp = bpf.program_mut(&quot;xdp&quot;)?.try_into()?;
</span><span class="boring">    probe.load()?;
</span><span class="boring">    probe.attach(&amp;iface, XdpFlags::default())?;
</span><span class="boring">
</span>    let mut perf_array = AsyncPerfEventArray::try_from(bpf.map_mut(&quot;EVENTS&quot;)?)?;
<span class="boring">
</span><span class="boring">    for cpu_id in online_cpus()? {
</span><span class="boring">        let mut buf = perf_array.open(cpu_id, None)?;
</span><span class="boring">
</span><span class="boring">        task::spawn(async move {
</span><span class="boring">            let mut buffers = (0..10)
</span><span class="boring">                .map(|_| BytesMut::with_capacity(1024))
</span><span class="boring">                .collect::&lt;Vec&lt;_&gt;&gt;();
</span><span class="boring">
</span><span class="boring">            loop {
</span><span class="boring">                let events = buf.read_events(&amp;mut buffers).await.unwrap();
</span><span class="boring">                for i in 0..events.read {
</span><span class="boring">                    let buf = &amp;mut buffers[i];
</span><span class="boring">                    let ptr = buf.as_ptr() as *const PacketLog;
</span><span class="boring">                    let data = unsafe { ptr.read_unaligned() };
</span><span class="boring">                    let src_addr = net::Ipv4Addr::from(data.ipv4_address);
</span><span class="boring">                    println!(&quot;LOG: SRC {}, ACTION {}&quot;, src_addr, data.action);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">    signal::ctrl_c().await.expect(&quot;failed to listen for event&quot;);
</span><span class="boring">    Ok::&lt;_, anyhow::Error&gt;(())
</span><span class="boring">}
</span></code></pre>
<p>Our <code>perf_array</code> is a mutable reference to the map that was created after the XDP program was loaded by Aya.</p>
<h2 id="writing-data"><a class="header" href="#writing-data">Writing Data</a></h2>
<p>Now we've got our maps set up, let's add some data!</p>
<h3 id="generating-bindings-to-vmlinuxh"><a class="header" href="#generating-bindings-to-vmlinuxh">Generating Bindings To vmlinux.h</a></h3>
<p>To get useful data to add to our maps, we first need some useful data structures to populate with data from the <code>XdpContext</code>.
We want to log the Source IP Address of incoming traffic, so we'll need to:</p>
<ol>
<li>Read the Ethernet Header to determine if this is an IPv4 Packet</li>
<li>Read the Source IP Address from the IPv4 Header</li>
</ol>
<p>The two structs in the kernel for this are <code>ethhdr</code> from <code>uapi/linux/if_ether.h</code> and <code>iphdr</code> from <code>uapi/linux/ip.h</code>.
If I were to use bindgen to generate Rust bindings for those headers, I'd be tied to the kernel version of the system that I'm developing on.
This is where <code>aya-gen</code> comes in to play. It can easily generate bindings for using the BTF information in <code>/sys/kernel/btf/vmlinux</code>.</p>
<p>Once the bindings are generated and checked in to our repository they shouldn't need to be regenerated again unless we need to add a new struct.</p>
<p>Lets use <code>xtask</code> to automate this so we can easily reproduce this file in future.</p>
<p>We'll add the following content to <code>xtask/src/codegen.rs</code></p>
<pre><code class="language-rust ignore">use aya_gen::btf_types;
use std::{
    fs::File,
    io::Write,
    path::{Path, PathBuf},
};

pub fn generate() -&gt; Result&lt;(), anyhow::Error&gt; {
    let dir = PathBuf::from(&quot;myapp-ebpf/src&quot;);
    let names: Vec&lt;&amp;str&gt; = vec![&quot;ethhdr&quot;, &quot;iphdr&quot;];
    let bindings = btf_types::generate(Path::new(&quot;/sys/kernel/btf/vmlinux&quot;), &amp;names, true)?;
    // Write the bindings to the $OUT_DIR/bindings.rs file.
    let mut out = File::create(dir.join(&quot;bindings.rs&quot;))?;
    write!(out, &quot;{}&quot;, bindings)?;
    Ok(())
}
</code></pre>
<p>This will generate a file called <code>myapp-ebpf/src/bindings.rs</code>. If you've chosen an application name other than <code>myapp</code> you'll need to adjust the path appropriately.</p>
<p>Add a new dependencies to <code>xtask/Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
aya-gen = { git = &quot;http://github.com/aya-rs/aya&quot;, branch = &quot;main&quot; }
</code></pre>
<p>Finally, we must add the command to the enum in <code>xtask/src/main.rs</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">mod build_ebpf;
</span><span class="boring">mod codegen;
</span><span class="boring">
</span><span class="boring">use std::process::exit;
</span><span class="boring">
</span><span class="boring">use structopt::StructOpt;
</span><span class="boring">#[derive(StructOpt)]
</span><span class="boring">pub struct Options {
</span><span class="boring">    #[structopt(subcommand)]
</span><span class="boring">    command: Command,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(StructOpt)]
enum Command {
    BuildEbpf(build_ebpf::Options),
    Codegen,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let opts = Options::from_args();
</span><span class="boring">
</span><span class="boring">    use Command::*;
</span><span class="boring">    let ret = match opts.command {
</span><span class="boring">        BuildEbpf(opts) =&gt; build_ebpf::build(opts),
</span><span class="boring">        Codegen =&gt; codegen::generate(),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    if let Err(e) = ret {
</span><span class="boring">        eprintln!(&quot;{:#}&quot;, e);
</span><span class="boring">        exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>And then add the new variant to the <code>match</code> statement:</p>
<pre><code class="language-rust ignore"><span class="boring">mod build_ebpf;
</span><span class="boring">mod codegen;
</span><span class="boring">
</span><span class="boring">use std::process::exit;
</span><span class="boring">
</span><span class="boring">use structopt::StructOpt;
</span><span class="boring">#[derive(StructOpt)]
</span><span class="boring">pub struct Options {
</span><span class="boring">    #[structopt(subcommand)]
</span><span class="boring">    command: Command,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(StructOpt)]
</span><span class="boring">enum Command {
</span><span class="boring">    BuildEbpf(build_ebpf::Options),
</span><span class="boring">    Codegen,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let opts = Options::from_args();
</span><span class="boring">
</span><span class="boring">    use Command::*;
</span>    let ret = match opts.command {
        BuildEbpf(opts) =&gt; build_ebpf::build(opts),
        Codegen =&gt; codegen::generate(),
    };
<span class="boring">
</span><span class="boring">    if let Err(e) = ret {
</span><span class="boring">        eprintln!(&quot;{:#}&quot;, e);
</span><span class="boring">        exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Once we've generated our file using <code>cargo xtask codegen</code> from the root of the project.</p>
<p>These can then be accessed from within <code>myapp-ebpf/src/main.rs</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{
</span><span class="boring">    bindings::xdp_action,
</span><span class="boring">    macros::{map, xdp},
</span><span class="boring">    maps::PerfEventArray,
</span><span class="boring">    programs::XdpContext,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use core::mem;
</span><span class="boring">use memoffset::offset_of;
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span>mod bindings;
use bindings::{ethhdr, iphdr};
<span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unreachable!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[map(name = &quot;EVENTS&quot;)]
</span><span class="boring">static mut EVENTS: PerfEventArray&lt;PacketLog&gt; = PerfEventArray::&lt;PacketLog&gt;::with_max_entries(1024, 0);
</span><span class="boring">
</span><span class="boring">#[xdp]
</span><span class="boring">pub fn xdp_firewall(ctx: XdpContext) -&gt; u32 {
</span><span class="boring">    match try_xdp_firewall(ctx) {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(_) =&gt; xdp_action::XDP_ABORTED,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[inline(always)]
</span><span class="boring">unsafe fn ptr_at&lt;T&gt;(ctx: &amp;XdpContext, offset: usize) -&gt; Result&lt;*const T, ()&gt; {
</span><span class="boring">    let start = ctx.data();
</span><span class="boring">    let end = ctx.data_end();
</span><span class="boring">    let len = mem::size_of::&lt;T&gt;();
</span><span class="boring">
</span><span class="boring">    if start + offset + len &gt; end {
</span><span class="boring">        return Err(());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok((start + offset) as *const T)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn try_xdp_firewall(ctx: XdpContext) -&gt; Result&lt;u32, ()&gt; {
</span><span class="boring">    let h_proto = u16::from_be(unsafe { *ptr_at(&amp;ctx, offset_of!(ethhdr, h_proto))? });
</span><span class="boring">    if h_proto != ETH_P_IP {
</span><span class="boring">        return Ok(xdp_action::XDP_PASS);
</span><span class="boring">    }
</span><span class="boring">    let source = u32::from_be(unsafe { *ptr_at(&amp;ctx, ETH_HDR_LEN + offset_of!(iphdr, saddr))? });
</span><span class="boring">
</span><span class="boring">    let log_entry = PacketLog {
</span><span class="boring">        ipv4_address: source,
</span><span class="boring">        action: xdp_action::XDP_PASS,
</span><span class="boring">    };
</span><span class="boring">    unsafe {
</span><span class="boring">        EVENTS.output(&amp;ctx, &amp;log_entry, 0);
</span><span class="boring">    }
</span><span class="boring">    Ok(xdp_action::XDP_PASS)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ETH_P_IP: u16 = 0x0800;
</span><span class="boring">const ETH_HDR_LEN: usize = mem::size_of::&lt;ethhdr&gt;();
</span></code></pre>
<h3 id="getting-packet-data-from-the-context"><a class="header" href="#getting-packet-data-from-the-context">Getting Packet Data From The Context</a></h3>
<p>The <code>XdpContext</code> contains two fields, <code>data</code> and <code>data_end</code>.
<code>data</code> is a pointer to the start of the data in kernel memory and <code>data_end</code>, a pointer to the end of the data in kernel memory. In order to access this data and ensure that the eBPF verifier is happy, we'll introduce a helper function:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{
</span><span class="boring">    bindings::xdp_action,
</span><span class="boring">    macros::{map, xdp},
</span><span class="boring">    maps::PerfEventArray,
</span><span class="boring">    programs::XdpContext,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use core::mem;
</span><span class="boring">use memoffset::offset_of;
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span><span class="boring">mod bindings;
</span><span class="boring">use bindings::{ethhdr, iphdr};
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unreachable!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[map(name = &quot;EVENTS&quot;)]
</span><span class="boring">static mut EVENTS: PerfEventArray&lt;PacketLog&gt; = PerfEventArray::&lt;PacketLog&gt;::with_max_entries(1024, 0);
</span><span class="boring">
</span><span class="boring">#[xdp]
</span><span class="boring">pub fn xdp_firewall(ctx: XdpContext) -&gt; u32 {
</span><span class="boring">    match try_xdp_firewall(ctx) {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(_) =&gt; xdp_action::XDP_ABORTED,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[inline(always)]
unsafe fn ptr_at&lt;T&gt;(ctx: &amp;XdpContext, offset: usize) -&gt; Result&lt;*const T, ()&gt; {
    let start = ctx.data();
    let end = ctx.data_end();
    let len = mem::size_of::&lt;T&gt;();

    if start + offset + len &gt; end {
        return Err(());
    }

    Ok((start + offset) as *const T)
}
<span class="boring">
</span><span class="boring">fn try_xdp_firewall(ctx: XdpContext) -&gt; Result&lt;u32, ()&gt; {
</span><span class="boring">    let h_proto = u16::from_be(unsafe { *ptr_at(&amp;ctx, offset_of!(ethhdr, h_proto))? });
</span><span class="boring">    if h_proto != ETH_P_IP {
</span><span class="boring">        return Ok(xdp_action::XDP_PASS);
</span><span class="boring">    }
</span><span class="boring">    let source = u32::from_be(unsafe { *ptr_at(&amp;ctx, ETH_HDR_LEN + offset_of!(iphdr, saddr))? });
</span><span class="boring">
</span><span class="boring">    let log_entry = PacketLog {
</span><span class="boring">        ipv4_address: source,
</span><span class="boring">        action: xdp_action::XDP_PASS,
</span><span class="boring">    };
</span><span class="boring">    unsafe {
</span><span class="boring">        EVENTS.output(&amp;ctx, &amp;log_entry, 0);
</span><span class="boring">    }
</span><span class="boring">    Ok(xdp_action::XDP_PASS)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ETH_P_IP: u16 = 0x0800;
</span><span class="boring">const ETH_HDR_LEN: usize = mem::size_of::&lt;ethhdr&gt;();
</span></code></pre>
<p>This function will ensure that before we access any data, we check that it's contained between <code>data</code> and <code>data_end</code>.
It is marked as <code>unsafe</code> because when calling the function, you must ensure that there is a valid <code>T</code> at that location or there will be undefined behaviour.</p>
<h3 id="writing-data-to-the-map"><a class="header" href="#writing-data-to-the-map">Writing Data To The Map</a></h3>
<p>With our helper function in place, we can:</p>
<ol>
<li>Read the Ethertype field to check if we have an IPv4 packet.</li>
<li>Read the IPv4 Source Address from the IP header</li>
</ol>
<p>First let's add another dependency on <code>memoffset = &quot;0.6&quot;</code> to <code>myapp-ebpf/Cargo.toml</code>, and then we'll change our <code>try_xdp_firewall</code> function to look like this:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{
</span><span class="boring">    bindings::xdp_action,
</span><span class="boring">    macros::{map, xdp},
</span><span class="boring">    maps::PerfEventArray,
</span><span class="boring">    programs::XdpContext,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use core::mem;
</span><span class="boring">use memoffset::offset_of;
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span><span class="boring">mod bindings;
</span><span class="boring">use bindings::{ethhdr, iphdr};
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unreachable!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[map(name = &quot;EVENTS&quot;)]
</span><span class="boring">static mut EVENTS: PerfEventArray&lt;PacketLog&gt; = PerfEventArray::&lt;PacketLog&gt;::with_max_entries(1024, 0);
</span><span class="boring">
</span><span class="boring">#[xdp]
</span><span class="boring">pub fn xdp_firewall(ctx: XdpContext) -&gt; u32 {
</span><span class="boring">    match try_xdp_firewall(ctx) {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(_) =&gt; xdp_action::XDP_ABORTED,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[inline(always)]
</span><span class="boring">unsafe fn ptr_at&lt;T&gt;(ctx: &amp;XdpContext, offset: usize) -&gt; Result&lt;*const T, ()&gt; {
</span><span class="boring">    let start = ctx.data();
</span><span class="boring">    let end = ctx.data_end();
</span><span class="boring">    let len = mem::size_of::&lt;T&gt;();
</span><span class="boring">
</span><span class="boring">    if start + offset + len &gt; end {
</span><span class="boring">        return Err(());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok((start + offset) as *const T)
</span><span class="boring">}
</span><span class="boring">
</span>fn try_xdp_firewall(ctx: XdpContext) -&gt; Result&lt;u32, ()&gt; {
    let h_proto = u16::from_be(unsafe { *ptr_at(&amp;ctx, offset_of!(ethhdr, h_proto))? });
    if h_proto != ETH_P_IP {
        return Ok(xdp_action::XDP_PASS);
    }
    let source = u32::from_be(unsafe { *ptr_at(&amp;ctx, ETH_HDR_LEN + offset_of!(iphdr, saddr))? });

    let log_entry = PacketLog {
        ipv4_address: source,
        action: xdp_action::XDP_PASS,
    };
    unsafe {
        EVENTS.output(&amp;ctx, &amp;log_entry, 0);
    }
    Ok(xdp_action::XDP_PASS)
}
<span class="boring">
</span><span class="boring">const ETH_P_IP: u16 = 0x0800;
</span><span class="boring">const ETH_HDR_LEN: usize = mem::size_of::&lt;ethhdr&gt;();
</span></code></pre>
<blockquote>
<p>ðŸ’¡ <strong>HINT: Reading Fields Using <code>offset_of!</code></strong></p>
<p>As there is limited stack space, it's more memory efficient to use the <code>offset_of!</code> macro to read
a single field from a struct, rather than reading the whole struct and accessing the field by name.</p>
</blockquote>
<p>Once we have our IPv4 source address, we can create a <code>PacketLog</code> struct and output this to our PerfEventArray</p>
<h2 id="reading-data"><a class="header" href="#reading-data">Reading Data</a></h2>
<h3 id="going-async"><a class="header" href="#going-async">Going Async</a></h3>
<p>In order to read from the <code>AsyncPerfEventArray</code>, we have to call <code>AsyncPerfEventArray::open()</code> for each online CPU, then we have to poll the file descriptor for events.
While this is do-able using <code>PerfEventArray</code> and <code>mio</code> or <code>epoll</code>, the code is much less easy to follow. Instead, we'll use <code>tokio</code> to make our user-space application async.</p>
<p>Let's add some dependencies to <code>myapp/src/Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
aya = { git = &quot;https://github.com/aya-rs/aya&quot;, branch=&quot;main&quot;, features=[&quot;async_tokio&quot;] }
myapp-common = { path = &quot;../myapp-common&quot;, features=[&quot;userspace&quot;] }
anyhow = &quot;1.0.42&quot;
bytes = &quot;1&quot;
tokio = { version = &quot;1.9.0&quot;, features = [&quot;full&quot;] }
</code></pre>
<p>And adjust our <code>main</code> function in <code>myapp/src/main.rs</code> to look like this:</p>
<pre><code class="language-rust ignore"><span class="boring">use aya::{
</span><span class="boring">    maps::perf::AsyncPerfEventArray,
</span><span class="boring">    programs::{Xdp, XdpFlags},
</span><span class="boring">    util::online_cpus,
</span><span class="boring">    Bpf,
</span><span class="boring">};
</span><span class="boring">use bytes::BytesMut;
</span><span class="boring">use std::{
</span><span class="boring">    convert::{TryFrom, TryInto},
</span><span class="boring">    env, fs, net,
</span><span class="boring">};
</span><span class="boring">use tokio::{signal, task};
</span><span class="boring">
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span>#[tokio::main]
async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let path = match env::args().nth(1) {
        Some(iface) =&gt; iface,
        None =&gt; panic!(&quot;not path provided&quot;),
    };
    let iface = match env::args().nth(2) {
        Some(iface) =&gt; iface,
        None =&gt; &quot;eth0&quot;.to_string(),
    };

    let data = fs::read(path)?;
    let mut bpf = Bpf::load(&amp;data)?;

    let probe: &amp;mut Xdp = bpf.program_mut(&quot;xdp&quot;)?.try_into()?;
    probe.load()?;
    probe.attach(&amp;iface, XdpFlags::default())?;

    let mut perf_array = AsyncPerfEventArray::try_from(bpf.map_mut(&quot;EVENTS&quot;)?)?;

    for cpu_id in online_cpus()? {
        let mut buf = perf_array.open(cpu_id, None)?;

        task::spawn(async move {
            let mut buffers = (0..10)
                .map(|_| BytesMut::with_capacity(1024))
                .collect::&lt;Vec&lt;_&gt;&gt;();

            loop {
                let events = buf.read_events(&amp;mut buffers).await.unwrap();
                for i in 0..events.read {
                    let buf = &amp;mut buffers[i];
                    let ptr = buf.as_ptr() as *const PacketLog;
                    let data = unsafe { ptr.read_unaligned() };
                    let src_addr = net::Ipv4Addr::from(data.ipv4_address);
                    println!(&quot;LOG: SRC {}, ACTION {}&quot;, src_addr, data.action);
                }
            }
        });
    }
    signal::ctrl_c().await.expect(&quot;failed to listen for event&quot;);
    Ok::&lt;_, anyhow::Error&gt;(())
}
</code></pre>
<p>This will now spawn a <code>tokio::task</code> to read each of the <code>AsyncPerfEventArrayBuffers</code> contained in out <code>AsyncPerfEventArray</code>.
When we receive an event, we use <code>read_unaligned</code> to read our data into a <code>PacketLog</code>.
We then use <code>println!</code> to log the event to the console.
We no longer need to sleep, as we run until we receive the <code>CTRL+C</code> signal.</p>
<h2 id="running-the-program"><a class="header" href="#running-the-program">Running the program</a></h2>
<pre><code class="language-console">cargo build
cargo xtask build-ebpf
sudo ./target/debug/myapp ./target/bpfel-unknown-none/debug/myapp wlp2s0
</code></pre>
<pre><code class="language-console">LOG: SRC 192.168.1.205, ACTION 2
LOG: SRC 192.168.1.21, ACTION 2
LOG: SRC 192.168.1.21, ACTION 2
LOG: SRC 18.168.253.132, ACTION 2
LOG: SRC 18.168.253.132, ACTION 2
LOG: SRC 18.168.253.132, ACTION 2
LOG: SRC 140.82.121.6, ACTION 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dropping-packets"><a class="header" href="#dropping-packets">Dropping Packets</a></h1>
<p>In the previous chapter, our XDP logged traffic. In this chapter we're going to extend it
to allow the dropping of traffic</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>In order for our program to drop packets, we're going to need a list of IP Addresses to drop.
Seeing as we want to do quick lookups a HashMap would be a good datastructure.
Therefore:</p>
<ul>
<li>We need to create a HashMap in our BPF Program</li>
<li>Check the IP Address from the packet against the HashMap to make a forwarding decision</li>
<li>Add entries to the blocklist from userspace</li>
</ul>
<h3 id="ebpf-map-creation-1"><a class="header" href="#ebpf-map-creation-1">eBPF: Map Creation</a></h3>
<p>Let's create a new map called <code>BLOCKLIST</code> in <code>myapp-ebpf/src/main.rs</code></p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{
</span><span class="boring">    bindings::xdp_action,
</span><span class="boring">    macros::{map, xdp},
</span><span class="boring">    maps::{HashMap, PerfEventArray},
</span><span class="boring">    programs::XdpContext,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use core::mem;
</span><span class="boring">use memoffset::offset_of;
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span><span class="boring">mod bindings;
</span><span class="boring">use bindings::{ethhdr, iphdr};
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unreachable!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[map(name = &quot;EVENTS&quot;)]
</span><span class="boring">static mut EVENTS: PerfEventArray&lt;PacketLog&gt; =
</span><span class="boring">    PerfEventArray::&lt;PacketLog&gt;::with_max_entries(1024, 0);
</span><span class="boring">
</span>#[map(name = &quot;BLOCKLIST&quot;)]
static mut BLOCKLIST: HashMap&lt;u32, u32&gt; = HashMap::&lt;u32, u32&gt;::with_max_entries(1024, 0);
<span class="boring">
</span><span class="boring">#[xdp]
</span><span class="boring">pub fn xdp_firewall(ctx: XdpContext) -&gt; u32 {
</span><span class="boring">    match try_xdp_firewall(ctx) {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(_) =&gt; xdp_action::XDP_ABORTED,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[inline(always)]
</span><span class="boring">unsafe fn ptr_at&lt;T&gt;(ctx: &amp;XdpContext, offset: usize) -&gt; Result&lt;*const T, ()&gt; {
</span><span class="boring">    let start = ctx.data();
</span><span class="boring">    let end = ctx.data_end();
</span><span class="boring">    let len = mem::size_of::&lt;T&gt;();
</span><span class="boring">
</span><span class="boring">    if start + offset + len &gt; end {
</span><span class="boring">        return Err(());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok((start + offset) as *const T)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn block_ip(address: u32) -&gt; bool {
</span><span class="boring">    unsafe { BLOCKLIST.get(&amp;address).is_some() }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn try_xdp_firewall(ctx: XdpContext) -&gt; Result&lt;u32, ()&gt; {
</span><span class="boring">    let h_proto = u16::from_be(unsafe { *ptr_at(&amp;ctx, offset_of!(ethhdr, h_proto))? });
</span><span class="boring">    if h_proto != ETH_P_IP {
</span><span class="boring">        return Ok(xdp_action::XDP_PASS);
</span><span class="boring">    }
</span><span class="boring">    let source = u32::from_be(unsafe { *ptr_at(&amp;ctx, ETH_HDR_LEN + offset_of!(iphdr, saddr))? });
</span><span class="boring">
</span><span class="boring">    let action = if block_ip(source) {
</span><span class="boring">        xdp_action::XDP_DROP
</span><span class="boring">    } else {
</span><span class="boring">        xdp_action::XDP_PASS
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let log_entry = PacketLog {
</span><span class="boring">        ipv4_address: source,
</span><span class="boring">        action: action,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    unsafe {
</span><span class="boring">        EVENTS.output(&amp;ctx, &amp;log_entry, 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(action)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ETH_P_IP: u16 = 0x0800;
</span><span class="boring">const ETH_HDR_LEN: usize = mem::size_of::&lt;ethhdr&gt;();
</span></code></pre>
<h3 id="ebpf-forwarding-decision"><a class="header" href="#ebpf-forwarding-decision">eBPF: Forwarding Decision</a></h3>
<p>In order to make our forwarding decision, we first need to read from the HashMap.
We'll implement a function called <code>block_ip</code> which will return <code>true</code> if the IP should be blocked and <code>false</code> if it should pass.</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{
</span><span class="boring">    bindings::xdp_action,
</span><span class="boring">    macros::{map, xdp},
</span><span class="boring">    maps::{HashMap, PerfEventArray},
</span><span class="boring">    programs::XdpContext,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use core::mem;
</span><span class="boring">use memoffset::offset_of;
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span><span class="boring">mod bindings;
</span><span class="boring">use bindings::{ethhdr, iphdr};
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unreachable!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[map(name = &quot;EVENTS&quot;)]
</span><span class="boring">static mut EVENTS: PerfEventArray&lt;PacketLog&gt; =
</span><span class="boring">    PerfEventArray::&lt;PacketLog&gt;::with_max_entries(1024, 0);
</span><span class="boring">
</span><span class="boring">#[map(name = &quot;BLOCKLIST&quot;)]
</span><span class="boring">static mut BLOCKLIST: HashMap&lt;u32, u32&gt; = HashMap::&lt;u32, u32&gt;::with_max_entries(1024, 0);
</span><span class="boring">
</span><span class="boring">#[xdp]
</span><span class="boring">pub fn xdp_firewall(ctx: XdpContext) -&gt; u32 {
</span><span class="boring">    match try_xdp_firewall(ctx) {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(_) =&gt; xdp_action::XDP_ABORTED,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[inline(always)]
</span><span class="boring">unsafe fn ptr_at&lt;T&gt;(ctx: &amp;XdpContext, offset: usize) -&gt; Result&lt;*const T, ()&gt; {
</span><span class="boring">    let start = ctx.data();
</span><span class="boring">    let end = ctx.data_end();
</span><span class="boring">    let len = mem::size_of::&lt;T&gt;();
</span><span class="boring">
</span><span class="boring">    if start + offset + len &gt; end {
</span><span class="boring">        return Err(());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok((start + offset) as *const T)
</span><span class="boring">}
</span><span class="boring">
</span>fn block_ip(address: u32) -&gt; bool {
    unsafe { BLOCKLIST.get(&amp;address).is_some() }
}
<span class="boring">
</span><span class="boring">fn try_xdp_firewall(ctx: XdpContext) -&gt; Result&lt;u32, ()&gt; {
</span><span class="boring">    let h_proto = u16::from_be(unsafe { *ptr_at(&amp;ctx, offset_of!(ethhdr, h_proto))? });
</span><span class="boring">    if h_proto != ETH_P_IP {
</span><span class="boring">        return Ok(xdp_action::XDP_PASS);
</span><span class="boring">    }
</span><span class="boring">    let source = u32::from_be(unsafe { *ptr_at(&amp;ctx, ETH_HDR_LEN + offset_of!(iphdr, saddr))? });
</span><span class="boring">
</span><span class="boring">    let action = if block_ip(source) {
</span><span class="boring">        xdp_action::XDP_DROP
</span><span class="boring">    } else {
</span><span class="boring">        xdp_action::XDP_PASS
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let log_entry = PacketLog {
</span><span class="boring">        ipv4_address: source,
</span><span class="boring">        action: action,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    unsafe {
</span><span class="boring">        EVENTS.output(&amp;ctx, &amp;log_entry, 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(action)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ETH_P_IP: u16 = 0x0800;
</span><span class="boring">const ETH_HDR_LEN: usize = mem::size_of::&lt;ethhdr&gt;();
</span></code></pre>
<p>We'll then call <code>block_ip</code> to determine the fate of the packet:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{
</span><span class="boring">    bindings::xdp_action,
</span><span class="boring">    macros::{map, xdp},
</span><span class="boring">    maps::{HashMap, PerfEventArray},
</span><span class="boring">    programs::XdpContext,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use core::mem;
</span><span class="boring">use memoffset::offset_of;
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span><span class="boring">mod bindings;
</span><span class="boring">use bindings::{ethhdr, iphdr};
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unreachable!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[map(name = &quot;EVENTS&quot;)]
</span><span class="boring">static mut EVENTS: PerfEventArray&lt;PacketLog&gt; =
</span><span class="boring">    PerfEventArray::&lt;PacketLog&gt;::with_max_entries(1024, 0);
</span><span class="boring">
</span><span class="boring">#[map(name = &quot;BLOCKLIST&quot;)]
</span><span class="boring">static mut BLOCKLIST: HashMap&lt;u32, u32&gt; = HashMap::&lt;u32, u32&gt;::with_max_entries(1024, 0);
</span><span class="boring">
</span><span class="boring">#[xdp]
</span><span class="boring">pub fn xdp_firewall(ctx: XdpContext) -&gt; u32 {
</span><span class="boring">    match try_xdp_firewall(ctx) {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(_) =&gt; xdp_action::XDP_ABORTED,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[inline(always)]
</span><span class="boring">unsafe fn ptr_at&lt;T&gt;(ctx: &amp;XdpContext, offset: usize) -&gt; Result&lt;*const T, ()&gt; {
</span><span class="boring">    let start = ctx.data();
</span><span class="boring">    let end = ctx.data_end();
</span><span class="boring">    let len = mem::size_of::&lt;T&gt;();
</span><span class="boring">
</span><span class="boring">    if start + offset + len &gt; end {
</span><span class="boring">        return Err(());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok((start + offset) as *const T)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn block_ip(address: u32) -&gt; bool {
</span><span class="boring">    unsafe { BLOCKLIST.get(&amp;address).is_some() }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn try_xdp_firewall(ctx: XdpContext) -&gt; Result&lt;u32, ()&gt; {
</span><span class="boring">    let h_proto = u16::from_be(unsafe { *ptr_at(&amp;ctx, offset_of!(ethhdr, h_proto))? });
</span><span class="boring">    if h_proto != ETH_P_IP {
</span><span class="boring">        return Ok(xdp_action::XDP_PASS);
</span><span class="boring">    }
</span><span class="boring">    let source = u32::from_be(unsafe { *ptr_at(&amp;ctx, ETH_HDR_LEN + offset_of!(iphdr, saddr))? });
</span><span class="boring">
</span>    let action = if block_ip(source) {
        xdp_action::XDP_DROP
    } else {
        xdp_action::XDP_PASS
    };
<span class="boring">
</span><span class="boring">    let log_entry = PacketLog {
</span><span class="boring">        ipv4_address: source,
</span><span class="boring">        action: action,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    unsafe {
</span><span class="boring">        EVENTS.output(&amp;ctx, &amp;log_entry, 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(action)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const ETH_P_IP: u16 = 0x0800;
</span><span class="boring">const ETH_HDR_LEN: usize = mem::size_of::&lt;ethhdr&gt;();
</span></code></pre>
<h3 id="userspace-adding-ip-addresses-to-block"><a class="header" href="#userspace-adding-ip-addresses-to-block">Userspace: Adding IP Addresses to Block</a></h3>
<p>In order to add addresses to block, we first need to get a reference to the <code>BLOCKLIST</code> map.
Once we have it, it's simply a case of calling <code>blocklist.insert()</code>.
We'll use the <code>IPv4Addr</code> type to represent our IP address as it's human-readable and can be easily converted to a <code>u32</code>. We'll block all traffic to <code>1.1.1.1</code> for this example.</p>
<pre><code class="language-rust ignore"><span class="boring">use aya::{
</span><span class="boring">    maps::perf::AsyncPerfEventArray,
</span><span class="boring">    programs::{Xdp, XdpFlags},
</span><span class="boring">    util::online_cpus,
</span><span class="boring">    Bpf,
</span><span class="boring">};
</span><span class="boring">use bytes::BytesMut;
</span><span class="boring">use std::{
</span><span class="boring">    convert::{TryFrom, TryInto},
</span><span class="boring">    env, fs, net,
</span><span class="boring">};
</span><span class="boring">use tokio::{signal, task};
</span><span class="boring">
</span><span class="boring">use myapp_common::PacketLog;
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
</span><span class="boring">    let path = match env::args().nth(1) {
</span><span class="boring">        Some(iface) =&gt; iface,
</span><span class="boring">        None =&gt; panic!(&quot;not path provided&quot;),
</span><span class="boring">    };
</span><span class="boring">    let iface = match env::args().nth(2) {
</span><span class="boring">        Some(iface) =&gt; iface,
</span><span class="boring">        None =&gt; &quot;eth0&quot;.to_string(),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let data = fs::read(path)?;
</span><span class="boring">    let mut bpf = Bpf::load(&amp;data)?;
</span><span class="boring">
</span><span class="boring">    let probe: &amp;mut Xdp = bpf.program_mut(&quot;xdp&quot;)?.try_into()?;
</span><span class="boring">    probe.load()?;
</span><span class="boring">    probe.attach(&amp;iface, XdpFlags::default())?;
</span><span class="boring">
</span><span class="boring">    let mut perf_array = AsyncPerfEventArray::try_from(bpf.map_mut(&quot;EVENTS&quot;)?)?;
</span><span class="boring">
</span><span class="boring">    for cpu_id in online_cpus()? {
</span><span class="boring">        let mut buf = perf_array.open(cpu_id, None)?;
</span><span class="boring">
</span><span class="boring">        task::spawn(async move {
</span><span class="boring">            let mut buffers = (0..10)
</span><span class="boring">                .map(|_| BytesMut::with_capacity(1024))
</span><span class="boring">                .collect::&lt;Vec&lt;_&gt;&gt;();
</span><span class="boring">
</span><span class="boring">            loop {
</span><span class="boring">                let events = buf.read_events(&amp;mut buffers).await.unwrap();
</span><span class="boring">                for i in 0..events.read {
</span><span class="boring">                    let buf = &amp;mut buffers[i];
</span><span class="boring">                    let ptr = buf.as_ptr() as *const PacketLog;
</span><span class="boring">                    let data = unsafe { ptr.read_unaligned() };
</span><span class="boring">                    let src_addr = net::Ipv4Addr::from(data.ipv4_address);
</span><span class="boring">                    println!(&quot;LOG: SRC {}, ACTION {}&quot;, src_addr, data.action);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">    signal::ctrl_c().await.expect(&quot;failed to listen for event&quot;);
</span><span class="boring">    Ok::&lt;_, anyhow::Error&gt;(())
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>ðŸ’¡ <strong>HINT: A quick note on Endianness</strong></p>
<p>IP Addresses are always NetworkEndian (BigEndian). However, in our eBPF Program we convert
it to HostEndian format using <code>u32::from_be</code>. Therefore it's correct to write our IP Addresses
in host-endian format when used as Map Keys.
If you had not converted it in your eBPF Program then you would need to convert it to
BigEndian format for use as a key.</p>
</blockquote>
<h2 id="running-the-program-1"><a class="header" href="#running-the-program-1">Running the program</a></h2>
<pre><code class="language-console">cargo build
cargo xtask build-ebpf
sudo ./target/debug/myapp ./target/bpfel-unknown-none/debug/myapp wlp2s0
</code></pre>
<pre><code class="language-console">LOG: SRC 192.168.1.205, ACTION 2
LOG: SRC 1.1.1.1, ACTION 1
LOG: SRC 192.168.1.21, ACTION 2
LOG: SRC 192.168.1.21, ACTION 2
LOG: SRC 18.168.253.132, ACTION 2
LOG: SRC 1.1.1.1, ACTION 1
LOG: SRC 18.168.253.132, ACTION 2
LOG: SRC 18.168.253.132, ACTION 2
LOG: SRC 1.1.1.1, ACTION 1
LOG: SRC 140.82.121.6, ACTION 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-aya"><a class="header" href="#working-with-aya">Working With Aya</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-values-from-a-context"><a class="header" href="#reading-values-from-a-context">Reading Values From A Context</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-aya-gen"><a class="header" href="#using-aya-gen">Using aya-gen</a></h1>
<p>Very often you will need to use type definitions that your running Linux kernel
uses in its source code. For example, you might need a definition of
<a href="https://elixir.bootlin.com/linux/v5.15.3/source/include/linux/sched.h#L723">task_struct</a>,
because you are about to write a BPF program which receives an
information about new scheduled process/task. Aya doesn't provide any
definition of this structure. What should be done to get that definition? And
we also need that definition in Rust, not in C.</p>
<p>That's what aya-gen is designed for. It's a tool which allows to generate Rust
bindings for specific kernel structures.</p>
<p>It can be installed with the following command:</p>
<pre><code class="language-bash">cargo install --git https://github.com/aya-rs/aya -- aya-gen
</code></pre>
<p>Ensure that you have <code>bpftool</code> installed in your system, <code>aya-gen</code> is not going
to work without it.</p>
<p>The syntax of the command is:</p>
<pre><code class="language-bash">$ aya-gen
aya-gen 0.1.0

USAGE:
    aya-gen &lt;SUBCOMMAND&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    btf-types
    help         Prints this message or the help of the given subcommand(s)
</code></pre>
<p>Let's assume that we want to generate Rust definition of
<a href="https://elixir.bootlin.com/linux/v5.15.3/source/include/linux/sched.h#L723">task_struct</a>.
Let's also assume that your project is called <code>myapp</code>. Your userspace part is
in <code>myapp</code> subdirectory, your eBPF part is in <code>myapp-ebpf</code>. We need to generate
the bindings for the eBPF part, which can be done with:</p>
<pre><code class="language-bash">aya-gen btf-types task_struct &gt; myapp-ebpf/src/vmlinux.rs
</code></pre>
<blockquote>
<p>ðŸ’¡ <strong>HINT: Generating for multiple types</strong></p>
<p>You can also specify multiple types to generate, for example:</p>
<pre><code class="language-bash">aya-gen btf-types task_struct dentry &gt; vmlinux.rs
</code></pre>
<p>But in the following example, we will focus only on <code>task_struct</code>.</p>
</blockquote>
<p>Then we can use <code>vmlinux</code> as a module with <code>mod vmlinux</code> in our eBPF program,
like here:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

#[allow(non_upper_case_globals)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
mod vmlinux;

use aya_bpf::{
    cty::{c_int, c_ulong},
    macros::{lsm, map},
    maps::HashMap,
    programs::LsmContext,
};

use vmlinux::task_struct;

#[map]
static mut PROCESSES: HashMap&lt;i32, i32&gt; = HashMap::with_max_entries(32768, 0);

#[lsm(name = &quot;task_alloc&quot;)]
pub fn task_alloc(ctx: LsmContext) -&gt; i32 {
    match unsafe { try_task_alloc(ctx) } {
        Ok(ret) =&gt; ret,
        Err(ret) =&gt; ret,
    }
}

unsafe fn try_task_alloc(ctx: LsmContext) -&gt; Result&lt;i32, i32&gt; {
    let task: *const task_struct = ctx.arg(0);
    let _clone_flags: c_ulong = ctx.arg(1);
    let retval: c_int = ctx.arg(2);

    // Save the PID of a new process in map.
    let pid = (*task).pid;
    PROCESSES.insert(&amp;pid, &amp;pid, 0).map_err(|e| e as i32)?;

    // Handle results of previous LSM programs.
    if retval != 0 {
        return Ok(retval);
    }

    Ok(0)
}

#[panic_handler]
fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    unsafe { core::hint::unreachable_unchecked() }
}
</code></pre>
<h2 id="potability-and-different-kernel-versions"><a class="header" href="#potability-and-different-kernel-versions">Potability and different kernel versions</a></h2>
<p>Structures generated by aya-gen are portable across different Linux kernel
versions thanks to mechanism called
<a href="https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html">BPF CO-RE</a>.
The structures are not simply generated from kernel headers. However, the
target kernel (regardless of version) should have <code>CONFIG_DEBUG_INFO_BTF</code>
option enabled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-aya-log"><a class="header" href="#using-aya-log">Using aya-log</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-types"><a class="header" href="#program-types">Program Types</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="probes"><a class="header" href="#probes">Probes</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracepoints"><a class="header" href="#tracepoints">Tracepoints</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sockets"><a class="header" href="#sockets">Sockets</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classifiers"><a class="header" href="#classifiers">Classifiers</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cgroups"><a class="header" href="#cgroups">Cgroups</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xdp"><a class="header" href="#xdp">XDP</a></h1>
<p>This page is a work in progress, please feel free to open a Pull Request!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
