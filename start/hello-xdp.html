<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hello XDP! - Building eBPF Programs With Aya</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../ebpf/index.html"><strong aria-hidden="true">2.</strong> eBPF Program Limitiations</a></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/development.html"><strong aria-hidden="true">3.1.</strong> Development Environment</a></li><li class="chapter-item expanded "><a href="../start/hello-xdp.html" class="active"><strong aria-hidden="true">3.2.</strong> Hello XDP!</a></li><li class="chapter-item expanded "><a href="../start/logging-packets.html"><strong aria-hidden="true">3.3.</strong> Logging Packets</a></li><li class="chapter-item expanded "><a href="../start/dropping-packets.html"><strong aria-hidden="true">3.4.</strong> Dropping Packets</a></li></ol></li><li class="chapter-item expanded "><a href="../aya/index.html"><strong aria-hidden="true">4.</strong> Working With Aya</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../aya/context.html"><strong aria-hidden="true">4.1.</strong> Reading Values From A Context</a></li><li class="chapter-item expanded "><a href="../aya/aya-gen.html"><strong aria-hidden="true">4.2.</strong> Using aya-gen</a></li><li class="chapter-item expanded "><a href="../aya/aya-log.html"><strong aria-hidden="true">4.3.</strong> Using aya-log</a></li></ol></li><li class="chapter-item expanded "><a href="../programs/index.html"><strong aria-hidden="true">5.</strong> Program Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs/probes.html"><strong aria-hidden="true">5.1.</strong> Probes</a></li><li class="chapter-item expanded "><a href="../programs/tracepoints.html"><strong aria-hidden="true">5.2.</strong> Tracepoints</a></li><li class="chapter-item expanded "><a href="../programs/sockets.html"><strong aria-hidden="true">5.3.</strong> Socket Programs</a></li><li class="chapter-item expanded "><a href="../programs/classifiers.html"><strong aria-hidden="true">5.4.</strong> Classifiers</a></li><li class="chapter-item expanded "><a href="../programs/cgroups.html"><strong aria-hidden="true">5.5.</strong> Cgroups</a></li><li class="chapter-item expanded "><a href="../programs/xdp.html"><strong aria-hidden="true">5.6.</strong> XDP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building eBPF Programs With Aya</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hello-xdp"><a class="header" href="#hello-xdp">Hello XDP!</a></h1>
<h2 id="example-project"><a class="header" href="#example-project">Example Project</a></h2>
<p>While there are myriad trace points to attach to and program types to write we should start somewhere simple.</p>
<p>XDP (eXpress Data Path) programs permit our eBPF program to make decisions about packets that have been received on the interface to which our program is attached. To keep things simple, we'll build a very simplistic firewall to permit or deny traffic.</p>
<h2 id="ebpf-component"><a class="header" href="#ebpf-component">eBPF Component</a></h2>
<h3 id="permit-all"><a class="header" href="#permit-all">Permit All</a></h3>
<p>We must first write the eBPF component of our program.
The logic for this program is located in <code>myapp-ebpf/src/main.rs</code> and currently looks like this:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use aya_bpf::{
    bindings::xdp_action,
    macros::xdp,
    programs::XdpContext,
};

#[xdp(name=&quot;myapp&quot;)]
pub fn myapp(ctx: XdpContext) -&gt; u32 {
    match unsafe { try_myapp(ctx) } {
        Ok(ret) =&gt; ret,
        Err(_) =&gt; xdp_action::XDP_ABORTED,
    }
}

unsafe fn try_myapp(_ctx: XdpContext) -&gt; Result&lt;u32, u32&gt; {
    Ok(xdp_action::XDP_PASS)
}

#[panic_handler]
fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    unsafe { core::hint::unreachable_unchecked() }
}
</code></pre>
<ul>
<li><code>#![no_std]</code> is required since we cannot use the standard library.</li>
<li><code>#![no_main]</code> is required as we have no main function.</li>
<li>The <code>#[panic_handler]</code> is required to keep the compiler happy, although it is never used since we cannot panic.</li>
</ul>
<p>This is a minimal generated XDP program that permits all traffic.</p>
<p>Let's look at some of its details.
First we make some <code>use</code> declarations:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span>use aya_bpf::{
    bindings::xdp_action,
    macros::xdp,
    programs::XdpContext,
};
<span class="boring">
</span><span class="boring">#[xdp(name=&quot;myapp&quot;)]
</span><span class="boring">pub fn myapp(ctx: XdpContext) -&gt; u32 {
</span><span class="boring">    match unsafe { try_myapp(ctx) } {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(_) =&gt; xdp_action::XDP_ABORTED,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">unsafe fn try_myapp(_ctx: XdpContext) -&gt; Result&lt;u32, u32&gt; {
</span><span class="boring">    Ok(xdp_action::XDP_PASS)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unsafe { core::hint::unreachable_unchecked() }
</span><span class="boring">}
</span></code></pre>
<p>Then our application logic:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{
</span><span class="boring">    bindings::xdp_action,
</span><span class="boring">    macros::xdp,
</span><span class="boring">    programs::XdpContext,
</span><span class="boring">};
</span><span class="boring">
</span>#[xdp(name=&quot;myapp&quot;)]
pub fn myapp(ctx: XdpContext) -&gt; u32 {
    match unsafe { try_myapp(ctx) } {
        Ok(ret) =&gt; ret,
        Err(_) =&gt; xdp_action::XDP_ABORTED,
    }
}

unsafe fn try_myapp(_ctx: XdpContext) -&gt; Result&lt;u32, u32&gt; {
    Ok(xdp_action::XDP_PASS)
}
<span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unsafe { core::hint::unreachable_unchecked() }
</span><span class="boring">}
</span></code></pre>
<ul>
<li><code>#[xdp(name=&quot;myapp&quot;)]</code> indicates that this function is an XDP program.</li>
<li>The <code>try_myapp</code> function returns a Result that currenlty permits all traffic.</li>
<li>The <code>myapp</code> program calls <code>try_myapp</code> and handles any errors by returning <code>XDP_ABORTED</code>, which will drop the packet and raise a tracepoint exception.</li>
</ul>
<p>Now we can compile this using <code>cargo xtask build-ebpf</code>.</p>
<h3 id="verifying-the-program"><a class="header" href="#verifying-the-program">Verifying The Program</a></h3>
<p>Let's take a look at the compiled eBPF program:</p>
<pre><code class="language-console">$ llvm-objdump -S target/bpfel-unknown-none/debug/myapp

target/bpfel-unknown-none/debug/myapp:  file format elf64-bpf


Disassembly of section xdp/myapp:

0000000000000000 &lt;myapp&gt;:
       0:       b7 00 00 00 02 00 00 00 r0 = 2
       1:       95 00 00 00 00 00 00 00 exit
</code></pre>
<p>We can see an <code>xdp/myapp</code> section here.
<code>r0 = 2</code> sets register <code>0</code> to <code>2</code>, which is the value of the <code>XDP_PASS</code> action.
<code>exit</code> ends the program.</p>
<p>Simple!</p>
<h2 id="user-space-component"><a class="header" href="#user-space-component">User-space Component</a></h2>
<p>Now our eBPF program is complete and compiled, we need a user-space program to load it and attach it to a trace point.
Fortunately, we have a generated program ready in <code>myapp/src/main.rs</code> which is going to do that for us.</p>
<h3 id="starting-out"><a class="header" href="#starting-out">Starting Out</a></h3>
<p>The generated application has the following content:</p>
<pre><code class="language-rust ignore">use aya::{include_bytes_aligned, Bpf};
use anyhow::Context;
use aya::programs::{Xdp, XdpFlags};
use log::info;
use simplelog::{ColorChoice, ConfigBuilder, LevelFilter, TermLogger, TerminalMode};
use std::convert::TryInto;
use structopt::StructOpt;
use tokio::signal;

#[derive(Debug, StructOpt)]
struct Opt {
    #[structopt(short, long, default_value = &quot;eth0&quot;)]
    iface: String,
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let opt = Opt::from_args();

    TermLogger::init(
        LevelFilter::Debug,
        ConfigBuilder::new()
            .set_target_level(LevelFilter::Error)
            .set_location_level(LevelFilter::Error)
            .build(),
        TerminalMode::Mixed,
        ColorChoice::Auto,
    )?;

    // This will include your eBPF object file as raw bytes at compile-time and load it at
    // runtime. This approach is recommended for most real-world use cases. If you would
    // like to specify the eBPF program at runtime rather than at compile-time, you can
    // reach for `Bpf::load_file` instead.
    let mut bpf = Bpf::load(include_bytes_aligned!(
        &quot;../../target/bpfel-unknown-none/release/myapp&quot;
    ))?;
    let program: &amp;mut Xdp = bpf.program_mut(&quot;myapp&quot;).unwrap().try_into()?;
    program.load()?;
    program.attach(&amp;opt.iface, XdpFlags::default())
        .context(&quot;failed to attach the XDP program with default flags - try changing XdpFlags::default() to XdpFlags::SKB_MODE&quot;)?;

    info!(&quot;Waiting for Ctrl-C...&quot;);
    signal::ctrl_c().await?;
    info!(&quot;Exiting...&quot;);

    Ok(())
}

</code></pre>
<p>Let's look at the details of this program.</p>
<p>There is a dependency on <code>tokio</code> added to <code>myapp/Cargo.toml</code> - <code>tokio</code>
provides the <a href="https://docs.rs/tokio/latest/tokio/signal/fn.ctrl_c.html">Ctrl-C handler</a> functionality and will also come useful later when we
expand the functionality of the initial program:</p>
<pre><code class="language-toml">tokio = { version = &quot;1.5.0&quot;, features = [&quot;macros&quot;, &quot;rt&quot;, &quot;rt-multi-thread&quot;, &quot;net&quot;, &quot;signal&quot;] }
</code></pre>
<p>The following <code>use</code> declarations are added at the top of the <code>myapp/src/main.rs</code>:</p>
<pre><code class="language-rust ignore">use aya::{include_bytes_aligned, Bpf};
use anyhow::Context;
use aya::programs::{Xdp, XdpFlags};
use log::info;
use simplelog::{ColorChoice, ConfigBuilder, LevelFilter, TermLogger, TerminalMode};
use std::convert::TryInto;
use structopt::StructOpt;
use tokio::signal;
<span class="boring">
</span><span class="boring">#[derive(Debug, StructOpt)]
</span><span class="boring">struct Opt {
</span><span class="boring">    #[structopt(short, long, default_value = &quot;eth0&quot;)]
</span><span class="boring">    iface: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
</span><span class="boring">    let opt = Opt::from_args();
</span><span class="boring">
</span><span class="boring">    TermLogger::init(
</span><span class="boring">        LevelFilter::Debug,
</span><span class="boring">        ConfigBuilder::new()
</span><span class="boring">            .set_target_level(LevelFilter::Error)
</span><span class="boring">            .set_location_level(LevelFilter::Error)
</span><span class="boring">            .build(),
</span><span class="boring">        TerminalMode::Mixed,
</span><span class="boring">        ColorChoice::Auto,
</span><span class="boring">    )?;
</span><span class="boring">
</span><span class="boring">    // This will include your eBPF object file as raw bytes at compile-time and load it at
</span><span class="boring">    // runtime. This approach is recommended for most real-world use cases. If you would
</span><span class="boring">    // like to specify the eBPF program at runtime rather than at compile-time, you can
</span><span class="boring">    // reach for `Bpf::load_file` instead.
</span><span class="boring">    let mut bpf = Bpf::load(include_bytes_aligned!(
</span><span class="boring">        &quot;../../target/bpfel-unknown-none/release/myapp&quot;
</span><span class="boring">    ))?;
</span><span class="boring">    let program: &amp;mut Xdp = bpf.program_mut(&quot;myapp&quot;).unwrap().try_into()?;
</span><span class="boring">    program.load()?;
</span><span class="boring">    program.attach(&amp;opt.iface, XdpFlags::default())
</span><span class="boring">        .context(&quot;failed to attach the XDP program with default flags - try changing XdpFlags::default() to XdpFlags::SKB_MODE&quot;)?;
</span><span class="boring">
</span><span class="boring">    info!(&quot;Waiting for Ctrl-C...&quot;);
</span><span class="boring">    signal::ctrl_c().await?;
</span><span class="boring">    info!(&quot;Exiting...&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span></code></pre>
<p>The async main function loads and runs our program:</p>
<pre><code class="language-rust ignore"><span class="boring">use aya::{include_bytes_aligned, Bpf};
</span><span class="boring">use anyhow::Context;
</span><span class="boring">use aya::programs::{Xdp, XdpFlags};
</span><span class="boring">use log::info;
</span><span class="boring">use simplelog::{ColorChoice, ConfigBuilder, LevelFilter, TermLogger, TerminalMode};
</span><span class="boring">use std::convert::TryInto;
</span><span class="boring">use structopt::StructOpt;
</span><span class="boring">use tokio::signal;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, StructOpt)]
</span><span class="boring">struct Opt {
</span><span class="boring">    #[structopt(short, long, default_value = &quot;eth0&quot;)]
</span><span class="boring">    iface: String,
</span><span class="boring">}
</span><span class="boring">
</span>#[tokio::main]
async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let opt = Opt::from_args();

    TermLogger::init(
        LevelFilter::Debug,
        ConfigBuilder::new()
            .set_target_level(LevelFilter::Error)
            .set_location_level(LevelFilter::Error)
            .build(),
        TerminalMode::Mixed,
        ColorChoice::Auto,
    )?;

    // This will include your eBPF object file as raw bytes at compile-time and load it at
    // runtime. This approach is recommended for most real-world use cases. If you would
    // like to specify the eBPF program at runtime rather than at compile-time, you can
    // reach for `Bpf::load_file` instead.
    let mut bpf = Bpf::load(include_bytes_aligned!(
        &quot;../../target/bpfel-unknown-none/release/myapp&quot;
    ))?;
    let program: &amp;mut Xdp = bpf.program_mut(&quot;myapp&quot;).unwrap().try_into()?;
    program.load()?;
    program.attach(&amp;opt.iface, XdpFlags::default())
        .context(&quot;failed to attach the XDP program with default flags - try changing XdpFlags::default() to XdpFlags::SKB_MODE&quot;)?;

    info!(&quot;Waiting for Ctrl-C...&quot;);
    signal::ctrl_c().await?;
    info!(&quot;Exiting...&quot;);

    Ok(())
}
<span class="boring">
</span></code></pre>
<p>The program optionally takes an argument for the interface we wish to attach it to (defaults to <code>eth0</code>).</p>
<p><code>include_bytes_aligned!</code> copies the contents of the BPF object file
into a variable at the compile time.
The statement <code>let mut bpf = Bpf::load_file(data)?;</code>:</p>
<ul>
<li>Reads the ELF contents</li>
<li>Creates any maps</li>
<li>If your system supports BPF Type Format (BTF), it will read the current BTF description and performs any necessary relocations</li>
</ul>
<p>Once our file is loaded, we can extract the XDP program with <code>let program: &amp;mut Xdp = bpf.program_mut(&quot;myapp&quot;)?.try_into()?;</code> and then load it in to the kernel with <code>program.load()</code>.</p>
<p>Finally, we can attach it to an interface with <code>program.attach(&amp;opt.iface, XdpFlags::default())?;</code>.  As the error message indicates, it is possible to use
<code>XdpFlags::SKB_MODE</code> instead of <code>XdpFlags::default()</code> as the second argument for
<code>program.attach</code> if the default attachment mode is not supported.</p>
<p>Let's try it out!</p>
<pre><code class="language-console"># change directory to the root or myapp
$ cargo build
$ cargo xtask run -- -h
myapp 0.1.0

USAGE:
    myapp [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -i, --iface &lt;iface&gt;     [default: eth0]

# add -i or --iface parameter if need to attach to an interface other than eth0
# - for example, cargo xtask run -- -i wlp2s0
$ cargo xtask run
10:58:21 [INFO] myapp: [myapp/src/main.rs:51] Waiting for Ctrl-C...
Exiting...
</code></pre>
<p>That was uneventful. Did it work?</p>
<blockquote>
<p>ðŸ’¡ <strong>HINT: Error Loading Program?</strong></p>
<p>If you get an error loading the program, try changing <code>XdpFlags::default()</code> to <code>XdpFlags::SKB_MODE</code></p>
</blockquote>
<h3 id="the-lifecycle-of-an-ebpf-program"><a class="header" href="#the-lifecycle-of-an-ebpf-program">The Lifecycle of an eBPF Program</a></h3>
<p>The program runs until CTRL+C is pressed and then exits.
On exit, Aya takes care of detaching the program for us.</p>
<p>If you issue the <code>sudo bpftool prog list</code> command when <code>myapp</code> is running you can verify that it is loaded:</p>
<pre><code class="language-console">84: xdp  tag 3b185187f1855c4c  gpl
        loaded_at 2022-01-07T12:17:54+0000  uid 0
        xlated 16B  jited 18B  memlock 4096B
        pids myapp(69184)
</code></pre>
<p>Running the command again once <code>myapp</code> has exited will show that the program is no longer running.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../start/development.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../start/logging-packets.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../start/development.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../start/logging-packets.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
